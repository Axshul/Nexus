<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nexus - Infinite Canvas Drawing App | Create Diagrams & Sketches Online</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="Nexus is a powerful infinite canvas drawing app for creating diagrams, sketches, and visual content. Auto-saves to URL, supports shapes, text, arrows, and collaborative sharing. Created by Axshul.">
    <meta name="keywords" content="drawing app, infinite canvas, diagram tool, sketch app, visual collaboration, online whiteboard, drawing software, design tool, Axshul">
    <meta name="author" content="Axshul">
    <meta name="robots" content="index, follow">
    <meta name="language" content="English">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://yoursite.com/Nexus/">
    <meta property="og:title" content="Nexus - Infinite Canvas Drawing App">
    <meta property="og:description" content="Create diagrams and sketches on an infinite dark canvas. Auto-saves to URL for easy sharing. Built by Axshul.">
    <meta property="og:image" content="https://yoursite.com/assets/img/nexus-preview.png">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://yoursite.com/Nexus/">
    <meta property="twitter:title" content="Nexus - Infinite Canvas Drawing App">
    <meta property="twitter:description" content="Create diagrams and sketches on an infinite dark canvas. Auto-saves to URL for easy sharing. Built by Axshul.">
    <meta property="twitter:image" content="https://yoursite.com/assets/img/nexus-preview.png">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://yoursite.com/Nexus/">
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="../assets/favicon_io/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="../assets/favicon_io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../assets/favicon_io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../assets/favicon_io/favicon-16x16.png">
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "Nexus",
        "description": "Infinite canvas drawing app for creating diagrams, sketches, and visual content",
        "url": "https://yoursite.com/Nexus/",
        "author": {
            "@type": "Person",
            "name": "Axshul"
        },
        "applicationCategory": "DesignApplication",
        "operatingSystem": "Web Browser",
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
        },
        "featureList": [
            "Infinite canvas drawing",
            "Auto-save to URL",
            "Shape tools (rectangles, circles, arrows)",
            "Text editing",
            "Image upload",
            "Collaborative sharing",
            "Undo/Redo functionality",
            "Export to PNG/SVG"
        ]
    }
    </script>
    <!-- Google Fonts -->
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Roboto+Mono&family=Playfair+Display&display=swap"
        rel="stylesheet">
    <!-- Fabric.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script src="https://unpkg.com/fabric-eraser-brush@1.1.0/dist/index.js"></script>
    <!-- LZ-String for compression -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.5.0/lz-string.min.js"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Marked.js for Markdown -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <!-- n8n Workflow Preview CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@webcomponents/webcomponentsjs@2.0.0/webcomponents-loader.js"></script>
    <script src="https://www.unpkg.com/lit@2.0.0-rc.2/polyfill-support.js"></script>
    <script type="module" src="https://cdn.jsdelivr.net/npm/@n8n_io/n8n-demo-component/n8n-demo.bundled.js"></script>
    <style>
        :root {
            --bg-color: #000000;
            --panel-bg: rgba(18, 18, 18, 0.9);
            --panel-border: #2A2A2A;
            --accent-color: #0077FF;
            --accent-green: #00CC88;
            --text-main: #ECECEC;
            --text-dim: #999999;
            --transition-speed: 0.15s;
            --sidebar-width: 260px;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            background-color: var(--bg-color);
            background-image:
                radial-gradient(circle, #1A1A1A 1px, transparent 1px);
            background-size: 30px 30px;
        }

        /* Top Toolbar */
        .toolbar {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel-bg);
            backdrop-filter: blur(12px);
            border: 1px solid var(--panel-border);
            border-radius: 10px;
            padding: 6px;
            display: flex;
            gap: 2px;
            z-index: 100;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
        }

        .tool-btn {
            background: transparent;
            border: none;
            color: var(--text-dim);
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition-speed);
            position: relative;
        }

        .tool-btn:hover {
            color: var(--text-main);
            background: rgba(255, 255, 255, 0.04);
        }

        .tool-btn.active {
            color: var(--accent-color);
            background: rgba(0, 119, 255, 0.08);
        }

        .tool-btn kbd {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 8px;
            opacity: 0.5;
            font-family: inherit;
        }

        .divider {
            width: 1px;
            height: 20px;
            background: var(--panel-border);
            margin: 0 6px;
            align-self: center;
        }

        /* Sidebar Property Panel */
        .sidebar {
            position: absolute;
            top: 80px;
            left: 15px;
            width: var(--sidebar-width);
            background: var(--panel-bg);
            backdrop-filter: blur(12px);
            border: 1px solid var(--panel-border);
            border-radius: 12px;
            padding: 16px;
            z-index: 200;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-height: calc(100vh - 160px);
            overflow-y: auto;
            transition: opacity 0.2s, transform 0.2s;
        }

        .sidebar.hidden {
            display: none;
        }

        .sidebar-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .sidebar-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .property-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .property-label {
            font-size: 13px;
            color: var(--text-main);
        }

        .swatch-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 6px;
        }

        .swatch {
            aspect-ratio: 1;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.1s;
        }

        .swatch:hover {
            transform: scale(1.15);
        }

        .swatch.active {
            border: 2px solid var(--accent-color);
        }

        /* Control inputs */
        input[type="range"] {
            flex: 1;
            height: 4px;
            background: var(--panel-border);
            border-radius: 2px;
            appearance: none;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 12px;
            height: 12px;
            background: var(--accent-color);
            border-radius: 50%;
            cursor: pointer;
        }

        select {
            background: #1A1A1A;
            border: 1px solid var(--panel-border);
            color: var(--text-main);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            outline: none;
        }

        /* Bottom Status Bar */
        .bottom-bar {
            position: absolute;
            bottom: 15px;
            left: 15px;
            right: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
            z-index: 100;
        }

        .bottom-group {
            display: flex;
            gap: 10px;
            pointer-events: all;
        }

        .status-indicator {
            background: var(--panel-bg);
            backdrop-filter: blur(12px);
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            padding: 6px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            color: var(--text-dim);
        }

        .status-dot {
            width: 6px;
            height: 6px;
            background: #444;
            border-radius: 50%;
            transition: all 0.3s;
        }

        .status-dot.active {
            background: var(--accent-green);
            box-shadow: 0 0 10px var(--accent-green);
        }

        /* Overlays */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .overlay.visible {
            opacity: 1;
            pointer-events: all;
        }

        .modal {
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 16px;
            padding: 30px;
            max-width: 400px;
            text-align: center;
        }

        .help-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
        }

        /* Global Color Selector */
        .global-color-selector {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            border: 1px solid var(--panel-border);
        }

        .global-color-input {
            width: 24px;
            height: 24px;
            border: none;
            border-radius: 4px;
            background: none;
            cursor: pointer;
            outline: none;
        }

        .global-color-label {
            font-size: 11px;
            color: var(--text-dim);
            font-weight: 500;
        }

        /* Creator Attribution */
        .creator-badge {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: var(--panel-bg);
            backdrop-filter: blur(12px);
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            padding: 6px 12px;
            font-size: 11px;
            color: var(--text-dim);
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .creator-badge:hover {
            color: var(--text-main);
            border-color: var(--accent-color);
        }

        /* Empty State */
        #empty-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            color: var(--text-dim);
            opacity: 0.5;
        }

        /* Improved responsive design */
        @media (max-width: 768px) {
            .toolbar {
                flex-wrap: wrap;
                max-width: 90vw;
            }
            
            .sidebar {
                width: calc(100vw - 30px);
                left: 15px;
                right: 15px;
            }
            
            .creator-badge {
                display: none;
            }
        }

        /* Better focus states for accessibility */
        .tool-btn:focus,
        input:focus,
        select:focus {
            outline: 2px solid var(--accent-color);
            outline-offset: 2px;
        }

        /* Loading state */
        .loading {
            opacity: 0.5;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="canvas-container">
        <canvas id="nexus-canvas"></canvas>
    </div>

    <!-- Toolbar -->
    <div class="toolbar">
        <button class="tool-btn active" data-tool="select" title="Selection">
            <i data-lucide="mouse-pointer-2"></i><kbd>V</kbd>
        </button>
        <button class="tool-btn" data-tool="hand" title="Pan">
            <i data-lucide="hand"></i><kbd>H</kbd>
        </button>
        <div class="divider"></div>
        
        <!-- Global Color Selector -->
        <div class="global-color-selector">
            <span class="global-color-label">Color</span>
            <input type="color" id="global-color-picker" class="global-color-input" value="#0077FF" title="Global Color">
        </div>
        <div class="divider"></div>
        
        <button class="tool-btn" data-tool="text" title="Text">
            <i data-lucide="type"></i><kbd>T</kbd>
        </button>
        <button class="tool-btn" data-tool="markdown" title="Markdown Box">
            <i data-lucide="file-text"></i><kbd>M</kbd>
        </button>
        <button class="tool-btn" data-tool="workflow" title="n8n Workflow">
            <i data-lucide="git-branch"></i><kbd>W</kbd>
        </button>
        <div class="divider"></div>
        <button class="tool-btn" id="library-toggle" title="Node Library">
            <i data-lucide="library"></i><kbd>L</kbd>
        </button>
        <button class="tool-btn" data-tool="rect" title="Rectangle">
            <i data-lucide="square"></i><kbd>R</kbd>
        </button>
        <button class="tool-btn" data-tool="circle" title="Circle">
            <i data-lucide="circle"></i><kbd>O</kbd>
        </button>
        <button class="tool-btn" data-tool="arrow" title="Arrow">
            <i data-lucide="move-up-right"></i><kbd>A</kbd>
        </button>
        <button class="tool-btn" data-tool="pencil" title="Pencil">
            <i data-lucide="pencil"></i><kbd>P</kbd>
        </button>
        <button class="tool-btn" data-tool="eraser" title="Eraser">
            <i data-lucide="eraser"></i><kbd>E</kbd>
        </button>
        <div class="divider"></div>
        <button class="tool-btn" id="img-upload-btn" title="Image">
            <i data-lucide="image"></i>
            <input type="file" id="img-input" accept="image/*" style="display:none">
        </button>
        <div class="divider"></div>
        <button class="tool-btn" id="clear-btn" title="Clear All">
            <i data-lucide="trash-2"></i>
        </button>
    </div>

    <!-- Sidebar Property Panel -->
    <div class="sidebar hidden" id="sidebar">
        <div class="sidebar-section">
            <div class="sidebar-title">n8n Nodes</div>
            <div class="property-row">
                <input type="text" id="node-search" placeholder="Search nodes..." style="width: 100%; background: #1A1A1A; border: 1px solid var(--panel-border); color: var(--text-main); padding: 6px; border-radius: 4px; font-size: 12px;">
            </div>
            <div id="node-library" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; max-height: 200px; overflow-y: auto; padding: 5px;">
                <!-- Nodes will be injected here -->
            </div>
        </div>

        <div class="sidebar-section">
            <div class="sidebar-title">Appearance</div>
            <div class="swatch-grid" id="swatch-grid">
                <div class="swatch" style="background: #0077FF" data-color="#0077FF"></div>
                <div class="swatch" style="background: #8A2BE2" data-color="#8A2BE2"></div>
                <div class="swatch" style="background: #00CC88" data-color="#00CC88"></div>
                <div class="swatch" style="background: #FFD700" data-color="#FFD700"></div>
                <div class="swatch" style="background: #FF4500" data-color="#FF4500"></div>
                <div class="swatch" style="background: #FFFFFF" data-color="#FFFFFF"></div>
                <div class="swatch" style="background: #333333" data-color="#333333"></div>
                <div class="swatch" style="background: #666666" data-color="#666666"></div>
                <div class="swatch" style="background: #FF69B4" data-color="#FF69B4"></div>
                <div class="swatch" style="background: #00FFFF" data-color="#00FFFF"></div>
                <div class="swatch" style="background: #7FFF00" data-color="#7FFF00"></div>
                <div class="swatch" style="background: transparent; border: 1px dashed #555" data-color="transparent">
                </div>
            </div>
            <div class="property-row">
                <input type="color" id="custom-color-picker"
                    style="width: 100%; height: 30px; border: none; border-radius: 4px; background: none; cursor: pointer;">
            </div>
        </div>

        <div class="sidebar-section">
            <div class="sidebar-title">Stroke & Style</div>
            <div class="property-row">
                <span class="property-label">Thickness</span>
                <input type="range" id="stroke-width" min="1" max="20" value="2">
            </div>
            <div class="property-row">
                <span class="property-label">Opacity</span>
                <input type="range" id="opacity" min="0" max="100" value="100">
            </div>
            <div class="property-row">
                <span class="property-label">Style</span>
                <select id="stroke-dash">
                    <option value="solid">Solid</option>
                    <option value="dashed">Dashed</option>
                    <option value="dotted">Dotted</option>
                </select>
            </div>
            <div class="property-row">
                <span class="property-label">Glow</span>
                <input type="range" id="glow" min="0" max="40" value="0">
            </div>
        </div>

        <div class="sidebar-section" id="text-options" style="display:none">
            <div class="sidebar-title">Typography</div>
            <div class="property-row">
                <select id="font-family" style="width:100%">
                    <option value="Inter">Inter</option>
                    <option value="Roboto Mono">Roboto Mono</option>
                    <option value="Playfair Display">Playfair</option>
                    <option value="System-ui">System</option>
                </select>
            </div>
        </div>

        <div class="sidebar-section">
            <div class="sidebar-title">Actions</div>
            <div class="property-row">
                <button class="tool-btn" id="bring-front" title="Bring to Front" style="flex:1"><i
                        data-lucide="layers-2"></i></button>
                <button class="tool-btn" id="send-back" title="Send to Back" style="flex:1"><i data-lucide="layers-2"
                        style="transform:rotate(180deg)"></i></button>
                <button class="tool-btn" id="lock-btn" title="Lock/Unlock" style="flex:1"><i
                        data-lucide="lock"></i></button>
                <button class="tool-btn" id="delete-btn" title="Delete" style="flex:1"><i data-lucide="x"></i></button>
            </div>
            <div class="property-row">
                <button class="tool-btn" id="group-btn" title="Group" style="flex:1"><i
                        data-lucide="combine"></i></button>
                <button class="tool-btn" id="ungroup-btn" title="Ungroup" style="flex:1"><i
                        data-lucide="split"></i></button>
            </div>
        </div>
    </div>

    <!-- Bottom Bar -->
    <div class="bottom-bar">
        <div class="bottom-group">
            <button class="tool-btn" id="undo-btn" title="Undo (Ctrl+Z)"><i data-lucide="undo-2"></i></button>
            <button class="tool-btn" id="redo-btn" title="Redo (Ctrl+Y)"><i data-lucide="redo-2"></i></button>
            <div class="divider"></div>
            <div class="status-indicator">
                <span id="zoom-level">100%</span>
            </div>
        </div>
        <div class="bottom-group">
            <button class="tool-btn" id="export-png" title="Export PNG"><i data-lucide="download"></i></button>
            <button class="tool-btn" id="export-svg" title="Export SVG"><i data-lucide="file-code"></i></button>
            <button class="tool-btn" id="export-json" title="Export JSON Project"><i data-lucide="file-json"></i></button>
            <button class="tool-btn" id="import-json" title="Import JSON Project"><i data-lucide="upload"></i></button>
            <button class="tool-btn" id="copy-link" title="Copy Share Link"><i data-lucide="link"></i></button>
            <div class="status-indicator">
                <span id="save-status">Synced</span>
                <div class="status-dot" id="status-dot"></div>
            </div>
        </div>
    </div>

    <!-- Creator Badge -->
    <div class="creator-badge">
        <i data-lucide="palette"></i>
        <span>Created by Axshul</span>
    </div>

    <!-- Help Button -->
    <button class="tool-btn help-btn" id="help-toggle">
        <i data-lucide="help-circle"></i>
    </button>

    <!-- Help Overlay -->
    <div class="overlay" id="help-overlay">
        <div class="modal">
            <h2 style="margin-top:0; color: var(--accent-color)">Nexus</h2>
            <p>Draw, type, and create on an infinite dark canvas.</p>
            <p style="font-size: 12px; color: var(--text-dim); margin: 10px 0;">Created by <strong>Axshul</strong></p>
            <div style="text-align: left; margin: 20px 0; font-size: 14px; color: var(--text-dim)">
                <p>• <b>Auto-save:</b> Every 10 seconds, the URL updates with your changes.</p>
                <p>• <b>Sharing:</b> Simply copy the URL and share it. It's your save file.</p>
                <p>• <b>Global Color:</b> Use the color picker in the toolbar to set colors for all new objects.</p>
                <p>• <b>Shortcuts:</b> V (Select), T (Text), R (Rect), P (Pencil), Del (Delete).</p>
            </div>
            <button class="tool-btn" id="help-close"
                style="width: 100%; background: var(--accent-color); color: white; margin-top: 10px;">Got it</button>
        </div>
    </div>

    <!-- Empty State -->
    <div id="empty-state">
        <h1 style="font-weight: 200; letter-spacing: 0.2em; margin-bottom: 10px;">N E X U S</h1>
        <p>Start creating. Everything is auto-saved to this URL.</p>
    </div>

    <script>
        // --- Core Setup ---
        const canvas = new fabric.Canvas('nexus-canvas', {
            width: window.innerWidth,
            height: window.innerHeight,
            backgroundColor: 'transparent',
            preserveObjectStacking: true,
            selection: true,
            perPixelTargeting: true,
            targetFindTolerance: 4
        });

        // Initialize Lucide
        lucide.createIcons();

        // --- State Management ---
        const state = {
            currentTool: 'select',
            currentColor: '#0077FF',
            isPanning: false,
            zoom: 1,
            history: [],
            historyIndex: -1,
            isLocked: false,
            lastSave: 0
        };

        // UI References
        const sidebar = document.getElementById('sidebar');
        const toolBtns = document.querySelectorAll('.tool-btn[data-tool]');
        const swatchGrid = document.getElementById('swatch-grid');
        const customColorPicker = document.getElementById('custom-color-picker');
        const globalColorPicker = document.getElementById('global-color-picker');
        const strokeWidthInput = document.getElementById('stroke-width');
        const opacityInput = document.getElementById('opacity');
        const strokeDashInput = document.getElementById('stroke-dash');
        const fontFamilyInput = document.getElementById('font-family');
        const zoomLevelText = document.getElementById('zoom-level');
        const saveStatusText = document.getElementById('save-status');
        const statusDot = document.getElementById('status-dot');
        const emptyState = document.getElementById('empty-state');

        // --- Node Library ---
        const n8nNodes = [
            { name: 'AI Agent', icon: 'https://cdn.jsdelivr.net/gh/n8n-io/n8n@master/packages/nodes-base/nodes/AiAgent/AiAgent.svg' },
            { name: 'HTTP Request', icon: 'https://cdn.jsdelivr.net/gh/n8n-io/n8n@master/packages/nodes-base/nodes/HttpRequest/httprequest.svg' },
            { name: 'Set', icon: 'https://cdn.jsdelivr.net/gh/n8n-io/n8n@master/packages/nodes-base/nodes/Set/set.svg' },
            { name: 'Code', icon: 'https://cdn.jsdelivr.net/gh/n8n-io/n8n@master/packages/nodes-base/nodes/Code/code.svg' },
            { name: 'Schedule', icon: 'https://cdn.jsdelivr.net/gh/n8n-io/n8n@master/packages/nodes-base/nodes/ScheduleTrigger/scheduleTrigger.svg' },
            { name: 'Webhook', icon: 'https://cdn.jsdelivr.net/gh/n8n-io/n8n@master/packages/nodes-base/nodes/Webhook/webhook.svg' },
            { name: 'Gmail', icon: 'https://cdn.jsdelivr.net/gh/n8n-io/n8n@master/packages/nodes-base/nodes/Gmail/gmail.svg' },
            { name: 'Slack', icon: 'https://cdn.jsdelivr.net/gh/n8n-io/n8n@master/packages/nodes-base/nodes/Slack/slack.svg' },
            { name: 'OpenAI', icon: 'https://cdn.jsdelivr.net/gh/n8n-io/n8n@master/packages/nodes-base/nodes/OpenAi/openai.svg' },
            { name: 'PostgreSQL', icon: 'https://cdn.jsdelivr.net/gh/n8n-io/n8n@master/packages/nodes-base/nodes/Postgres/postgres.svg' },
            { name: 'Airtable', icon: 'https://cdn.jsdelivr.net/gh/n8n-io/n8n@master/packages/nodes-base/nodes/Airtable/airtable.svg' },
            { name: 'Discord', icon: 'https://cdn.jsdelivr.net/gh/n8n-io/n8n@master/packages/nodes-base/nodes/Discord/discord.svg' },
            { name: 'Filter', icon: 'https://cdn.jsdelivr.net/gh/n8n-io/n8n@master/packages/nodes-base/nodes/Filter/filter.svg' },
            { name: 'Merge', icon: 'https://cdn.jsdelivr.net/gh/n8n-io/n8n@master/packages/nodes-base/nodes/Merge/merge.svg' },
            { name: 'Split In Batches', icon: 'https://cdn.jsdelivr.net/gh/n8n-io/n8n@master/packages/nodes-base/nodes/SplitInBatches/splitInBatches.svg' },
            { name: 'Wait', icon: 'https://cdn.jsdelivr.net/gh/n8n-io/n8n@master/packages/nodes-base/nodes/Wait/wait.svg' }
        ];

        function initNodeLibrary() {
            const library = document.getElementById('node-library');
            const search = document.getElementById('node-search');

            const renderNodes = (filter = '') => {
                library.innerHTML = '';
                n8nNodes.filter(n => n.name.toLowerCase().includes(filter.toLowerCase())).forEach(node => {
                    const el = document.createElement('div');
                    el.className = 'tool-btn';
                    el.style.padding = '8px';
                    el.title = node.name;
                    el.innerHTML = `<img src="${node.icon}" style="width: 24px; height: 24px;">`;
                    el.onclick = () => addNodeToCanvas(node);
                    library.appendChild(el);
                });
            };

            search.oninput = (e) => renderNodes(e.target.value);
            renderNodes();

            document.getElementById('library-toggle').onclick = () => {
                const sidebar = document.getElementById('sidebar');
                sidebar.classList.toggle('library-open');
                sidebar.classList.toggle('hidden', !sidebar.classList.contains('library-open') && !canvas.getActiveObject());
            };
        }

        function addNodeToCanvas(node) {
            fabric.Image.fromURL(node.icon, (img) => {
                img.scaleToWidth(60);
                img.set({
                    left: canvas.getCenter().left,
                    top: canvas.getCenter().top,
                    originX: 'center',
                    originY: 'center',
                    id: generateId()
                });
                canvas.add(img);
                canvas.setActiveObject(img);
                saveState();
            }, { crossOrigin: 'anonymous' });
        }

        // --- UI Initialization ---
        function initUI() {
            initNodeLibrary();
            // Tool selection
            toolBtns.forEach(btn => {
                btn.onclick = () => setTool(btn.dataset.tool);
            });

            // Swatches
            document.querySelectorAll('.swatch').forEach(swatch => {
                swatch.onclick = () => {
                    const color = swatch.dataset.color;
                    setColor(color);
                    
                    // If we have selected text objects, update their color immediately
                    const activeObjects = canvas.getActiveObjects();
                    activeObjects.forEach(obj => {
                        if (obj.type === 'i-text' || obj.type === 'text') {
                            obj.set('fill', color);
                            obj.set('stroke', 'transparent');
                            obj.set('strokeWidth', 0);
                        }
                    });
                    if (activeObjects.length) {
                        canvas.renderAll();
                        saveState();
                    }
                };
            });

            customColorPicker.oninput = (e) => {
                const color = e.target.value;
                setColor(color);
                
                // Immediate update for text objects
                const activeObjects = canvas.getActiveObjects();
                activeObjects.forEach(obj => {
                    if (obj.type === 'i-text' || obj.type === 'text') {
                        obj.set('fill', color);
                        obj.set('stroke', 'transparent');
                        obj.set('strokeWidth', 0);
                    }
                });
                if (activeObjects.length) {
                    canvas.renderAll();
                }
            };
            
            globalColorPicker.oninput = (e) => {
                const color = e.target.value;
                setColor(color);
                
                // Immediate update for text objects
                const activeObjects = canvas.getActiveObjects();
                activeObjects.forEach(obj => {
                    if (obj.type === 'i-text' || obj.type === 'text') {
                        obj.set('fill', color);
                        obj.set('stroke', 'transparent');
                        obj.set('strokeWidth', 0);
                    }
                });
                if (activeObjects.length) {
                    canvas.renderAll();
                }
            };

            // Property updates
            strokeWidthInput.oninput = (e) => updateActiveObjects('strokeWidth', parseInt(e.target.value));
            opacityInput.oninput = (e) => updateActiveObjects('opacity', parseInt(e.target.value) / 100);
            document.getElementById('glow').oninput = (e) => {
                const val = parseInt(e.target.value);
                const activeObjects = canvas.getActiveObjects();
                activeObjects.forEach(obj => {
                    if (val === 0) obj.set('shadow', null);
                    else obj.set('shadow', new fabric.Shadow({
                        color: obj.stroke || state.currentColor,
                        blur: val,
                        offsetX: 0,
                        offsetY: 0
                    }));
                });
                canvas.renderAll();
                saveState();
            };
            strokeDashInput.onchange = (e) => {
                const val = e.target.value;
                let dash = [];
                if (val === 'dashed') dash = [10, 5];
                else if (val === 'dotted') dash = [2, 2];
                updateActiveObjects('strokeDashArray', dash);
            };
            fontFamilyInput.onchange = (e) => updateActiveObjects('fontFamily', e.target.value);

            // Action buttons
            document.getElementById('bring-front').onclick = () => {
                canvas.getActiveObjects().forEach(obj => canvas.bringToFront(obj));
                canvas.renderAll();
                saveState();
            };
            document.getElementById('send-back').onclick = () => {
                canvas.getActiveObjects().forEach(obj => canvas.sendToBack(obj));
                canvas.renderAll();
                saveState();
            };
            document.getElementById('delete-btn').onclick = deleteSelected;
            document.getElementById('lock-btn').onclick = toggleLock;
            document.getElementById('clear-btn').onclick = clearCanvas;
            document.getElementById('group-btn').onclick = groupSelected;
            document.getElementById('ungroup-btn').onclick = ungroupSelected;
            document.getElementById('undo-btn').onclick = undo;
            document.getElementById('redo-btn').onclick = redo;
            document.getElementById('export-png').onclick = exportPNG;
            document.getElementById('export-svg').onclick = exportSVG;
            document.getElementById('export-json').onclick = exportJSON;
            document.getElementById('import-json').onclick = importJSON;
            document.getElementById('copy-link').onclick = copyShareLink;

            // Help overlay
            document.getElementById('help-toggle').onclick = () => document.getElementById('help-overlay').classList.add('visible');
            document.getElementById('help-close').onclick = () => document.getElementById('help-overlay').classList.remove('visible');

            // Image upload
            document.getElementById('img-upload-btn').onclick = handleImageBtn;
            document.getElementById('img-input').onchange = handleImageUpload;

            // Global Resize
            window.onresize = () => {
                canvas.setDimensions({ width: window.innerWidth, height: window.innerHeight });
                canvas.renderAll();
            };
        }

        // --- Fabric Extensions & ID Management ---
        fabric.Object.prototype.includeDefaultValues = false;
        fabric.Object.prototype.toObject = (function (toObject) {
            return function (propertiesToInclude) {
                return toObject.call(this, ['id'].concat(propertiesToInclude));
            };
        })(fabric.Object.prototype.toObject);

        fabric.Polyline.prototype.toObject = (function (toObject) {
            return function (propertiesToInclude) {
                return toObject.call(this, [
                    'x1', 'y1', 'x2', 'y2',
                    'startObjId', 'endObjId',
                    'startPort', 'endPort'
                ].concat(propertiesToInclude));
            };
        })(fabric.Polyline.prototype.toObject);

        function generateId() {
            return 'obj_' + Math.random().toString(36).substr(2, 9);
        }

        // --- Core Functions ---

        const ports = [
            { id: 'top', x: 0.5, y: 0 },
            { id: 'bottom', x: 0.5, y: 1 },
            { id: 'left', x: 0, y: 0.5 },
            { id: 'right', x: 1, y: 0.5 }
        ];

        function getPortCoords(obj, portId) {
            const width = obj.width * obj.scaleX;
            const height = obj.height * obj.scaleY;
            const port = ports.find(p => p.id === portId);

            let x = (port.x - 0.5) * width;
            let y = (port.y - 0.5) * height;

            const rad = fabric.util.degreesToRadians(obj.angle);
            const rx = x * Math.cos(rad) - y * Math.sin(rad);
            const ry = x * Math.sin(rad) + y * Math.cos(rad);

            return {
                x: obj.left + rx,
                y: obj.top + ry
            };
        }

        function getNearestPort(obj, pointer) {
            const coords = [
                { id: 'top', ...getPortCoords(obj, 'top') },
                { id: 'bottom', ...getPortCoords(obj, 'bottom') },
                { id: 'left', ...getPortCoords(obj, 'left') },
                { id: 'right', ...getPortCoords(obj, 'right') }
            ];
            
            let nearest = coords[0];
            let minDist = Math.hypot(pointer.x - coords[0].x, pointer.y - coords[0].y);

            coords.forEach(c => {
                const dist = Math.hypot(pointer.x - c.x, pointer.y - c.y);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = c;
                }
            });

            return nearest;
        }

        function createArrow(x1, y1, x2, y2) {
            const arrow = new fabric.Polyline([{x:0, y:0}], {
                stroke: state.currentColor,
                strokeWidth: parseInt(strokeWidthInput.value) || 2,
                fill: 'transparent',
                strokeLineCap: 'round',
                strokeLineJoin: 'round',
                originX: 'left',
                originY: 'center',
                objectCaching: false,
                selectable: true,
                evented: true,
                x1: x1,
                y1: y1,
                x2: x2 || x1,
                y2: y2 || y1
            });
            updateArrow(arrow);
            return arrow;
        }

        function updateArrow(arrow) {
            if (!arrow.startObj && arrow.startObjId) {
                arrow.startObj = canvas.getObjects().find(o => o.id === arrow.startObjId);
            }
            if (!arrow.endObj && arrow.endObjId) {
                arrow.endObj = canvas.getObjects().find(o => o.id === arrow.endObjId);
            }

            let p1 = { x: arrow.x1, y: arrow.y1 };
            let p2 = { x: arrow.x2, y: arrow.y2 };

            if (arrow.startObj) p1 = getPortCoords(arrow.startObj, arrow.startPort);
            if (arrow.endObj) p2 = getPortCoords(arrow.endObj, arrow.endPort);

            const headLength = 15;
            const headWidth = 8;
            const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);

            const points = [
                { x: 0, y: 0 },
                { x: dist, y: 0 },
                { x: dist - headLength, y: -headWidth },
                { x: dist, y: 0 },
                { x: dist - headLength, y: headWidth }
            ];

            arrow.set({
                left: p1.x,
                top: p1.y,
                points: points,
                angle: fabric.util.radiansToDegrees(angle)
            });
            arrow.setCoords();
        }

        function updateConnectedArrows(obj) {
            canvas.getObjects('polyline').forEach(arrow => {
                if (arrow.startObj === obj || arrow.endObj === obj) {
                    updateArrow(arrow);
                }
            });
        }

        // --- Markdown Block Class ---
        fabric.MarkdownBlock = fabric.util.createClass(fabric.Group, {
            type: 'markdown-block',
            initialize: function(text, options) {
                options = options || {};
                this.markdownText = text || '# Markdown\nDouble-click to edit';
                const width = options.width || 300;
                const height = options.height || 200;

                const rect = new fabric.Rect({
                    width: width,
                    height: height,
                    fill: '#121212',
                    stroke: '#2A2A2A',
                    strokeWidth: 2,
                    rx: 12,
                    ry: 12,
                    originX: 'center',
                    originY: 'center'
                });

                this.callSuper('initialize', [rect], options);
                this.updateContent();
            },
            updateContent: function() {
                const self = this;
                const width = this.width;
                const height = this.height;
                const html = marked.parse(this.markdownText);

                const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}">
                    <foreignObject width="100%" height="100%">
                        <div xmlns="http://www.w3.org/1999/xhtml" style="color: #ECECEC; padding: 20px; font-family: 'Inter', sans-serif; font-size: 14px; line-height: 1.5; overflow: hidden;">
                            <style>
                                h1, h2, h3 { color: #0077FF; margin: 0 0 10px 0; font-size: 18px; }
                                p { margin: 0 0 10px 0; }
                                code { background: #2A2A2A; padding: 2px 4px; border-radius: 4px; font-family: 'Roboto Mono', monospace; font-size: 12px; }
                                ul, ol { padding-left: 20px; margin: 0 0 10px 0; }
                                strong { color: #00CC88; }
                            </style>
                            ${html}
                        </div>
                    </foreignObject>
                </svg>`;

                const url = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svg);
                fabric.Image.fromURL(url, function(img) {
                    if (self._objects[1]) self.remove(self._objects[1]);
                    img.set({ originX: 'center', originY: 'center' });
                    self.addWithUpdate(img);
                    canvas.renderAll();
                });
            },
            toObject: function() {
                return fabric.util.object.extend(this.callSuper('toObject'), {
                    markdownText: this.markdownText
                });
            }
        });

        fabric.MarkdownBlock.fromObject = function(object, callback) {
            const block = new fabric.MarkdownBlock(object.markdownText, object);
            callback(block);
        };

        // --- n8n Workflow Node Class ---
        fabric.WorkflowNode = fabric.util.createClass(fabric.Rect, {
            type: 'workflow-node',
            initialize: function(workflowData, options) {
                options = options || {};
                options.width = options.width || 600;
                options.height = options.height || 400;
                options.fill = 'rgba(255, 108, 55, 0.05)';
                options.stroke = '#FF6C37';
                options.strokeWidth = 2;
                options.rx = 12;
                options.ry = 12;

                this.callSuper('initialize', options);
                this.workflowData = workflowData || { nodes: [], connections: {} };

                this.on('added', () => this.createDOMElement());
                this.on('removed', () => this.removeDOMElement());
            },
            createDOMElement: function() {
                if (this.domElement) return;
                this.domElement = document.createElement('n8n-demo');
                this.domElement.className = 'workflow-overlay';
                this.domElement.style.position = 'fixed';
                this.domElement.style.zIndex = '50';
                this.domElement.style.pointerEvents = 'all';
                this.domElement.style.borderRadius = '12px';
                this.domElement.style.overflow = 'hidden';
                this.domElement.setAttribute('workflow', JSON.stringify(this.workflowData));
                document.body.appendChild(this.domElement);
                this.syncDOM();
            },
            removeDOMElement: function() {
                if (this.domElement) {
                    this.domElement.remove();
                    this.domElement = null;
                }
            },
            syncDOM: function() {
                if (!this.domElement) return;
                const vpt = canvas.viewportTransform;
                const zoom = canvas.getZoom();

                const point = new fabric.Point(this.left, this.top);
                const screenPoint = fabric.util.transformPoint(point, vpt);

                const width = this.width * this.scaleX * zoom;
                const height = this.height * this.scaleY * zoom;

                this.domElement.style.width = `${width}px`;
                this.domElement.style.height = `${height}px`;
                this.domElement.style.left = `${screenPoint.x - width/2}px`;
                this.domElement.style.top = `${screenPoint.y - height/2}px`;
                this.domElement.style.transform = `rotate(${this.angle}deg)`;

                // Toggle visibility if off-screen
                const isOffScreen = screenPoint.x + width/2 < 0 || screenPoint.y + height/2 < 0 ||
                                   screenPoint.x - width/2 > window.innerWidth || screenPoint.y - height/2 > window.innerHeight;
                this.domElement.style.display = isOffScreen ? 'none' : 'block';
            },
            toObject: function() {
                return fabric.util.object.extend(this.callSuper('toObject'), {
                    workflowData: this.workflowData
                });
            }
        });

        fabric.WorkflowNode.fromObject = function(object, callback) {
            callback(new fabric.WorkflowNode(object.workflowData, object));
        };

        function setTool(tool) {
            state.currentTool = tool;
            toolBtns.forEach(btn => btn.classList.toggle('active', btn.dataset.tool === tool));

            canvas.isDrawingMode = (tool === 'pencil' || tool === 'eraser');
            canvas.selection = (tool === 'select');
            canvas.defaultCursor = (tool === 'hand') ? 'grab' : (tool === 'select' ? 'default' : 'crosshair');

            if (canvas.isDrawingMode) {
                canvas.freeDrawingBrush = (tool === 'eraser')
                    ? new fabric.EraserBrush(canvas)
                    : new fabric.PencilBrush(canvas);
                canvas.freeDrawingBrush.width = parseInt(strokeWidthInput.value);
                if (tool === 'pencil') canvas.freeDrawingBrush.color = state.currentColor;
            }

            if (tool !== 'select') {
                canvas.discardActiveObject();
                canvas.renderAll();
            }
        }

        function setColor(color) {
            state.currentColor = color;
            customColorPicker.value = color === 'transparent' ? '#000000' : color;
            globalColorPicker.value = color === 'transparent' ? '#000000' : color;
            
            // Handle color updates for active objects
            const activeObjects = canvas.getActiveObjects();
            if (activeObjects.length) {
                activeObjects.forEach(obj => {
                    if (obj.type === 'i-text' || obj.type === 'text') {
                        // For text objects, only update fill (text color)
                        obj.set('fill', color);
                        // Ensure stroke is transparent for text
                        obj.set('stroke', 'transparent');
                    } else {
                        // For other objects, update both stroke and fill
                        if (obj.type !== 'line' && obj.type !== 'polyline') {
                            obj.set('fill', color === 'transparent' ? 'transparent' : color + '33');
                        }
                        obj.set('stroke', color);
                    }
                });
                canvas.renderAll();
                saveState();
            }

            if (state.currentTool === 'pencil' && canvas.freeDrawingBrush) {
                canvas.freeDrawingBrush.color = color;
            }

            document.querySelectorAll('.swatch').forEach(s => {
                s.classList.toggle('active', s.dataset.color === color);
            });
        }

        function updateActiveObjects(prop, value) {
            const activeObjects = canvas.getActiveObjects();
            if (activeObjects.length) {
                activeObjects.forEach(obj => {
                    // Special handling for text objects
                    if (obj.type === 'i-text' || obj.type === 'text') {
                        if (prop === 'stroke') {
                            // Don't apply stroke to text, use fill instead
                            obj.set('fill', value);
                            obj.set('stroke', 'transparent');
                        } else if (prop === 'fill') {
                            obj.set('fill', value);
                        } else {
                            obj.set(prop, value);
                        }
                    } else {
                        // Handle other objects normally
                        if (prop === 'fill' && (obj.type === 'line' || obj.type === 'polyline')) return;
                        obj.set(prop, value);
                    }
                });
                canvas.renderAll();
                saveState();
            }
        }

        function groupSelected() {
            if (!canvas.getActiveObject()) return;
            if (canvas.getActiveObject().type !== 'activeSelection') return;
            canvas.getActiveObject().toGroup();
            canvas.requestRenderAll();
            saveState();
        }

        function ungroupSelected() {
            if (!canvas.getActiveObject()) return;
            if (canvas.getActiveObject().type !== 'group') return;
            canvas.getActiveObject().toActiveSelection();
            canvas.requestRenderAll();
            saveState();
        }

        function deleteSelected() {
            const activeObjects = canvas.getActiveObjects();
            if (activeObjects.length) {
                canvas.remove(...activeObjects);
                canvas.discardActiveObject();
                saveState();
            }
        }

        function toggleLock() {
            const activeObjects = canvas.getActiveObjects();
            if (activeObjects.length === 0) return;

            const isLocked = !activeObjects[0].lockMovementX;
            activeObjects.forEach(obj => {
                obj.lockMovementX = isLocked;
                obj.lockMovementY = isLocked;
                obj.lockRotation = isLocked;
                obj.lockScalingX = isLocked;
                obj.lockScalingY = isLocked;
                if (obj.type === 'i-text') obj.editable = !isLocked;
                obj.hasControls = !isLocked;
            });

            const lockBtn = document.getElementById('lock-btn');
            lockBtn.innerHTML = isLocked ? '<i data-lucide="lock"></i>' : '<i data-lucide="unlock"></i>';
            lockBtn.classList.toggle('active', isLocked);
            lucide.createIcons();
            canvas.renderAll();
            saveState();
        }

        function clearCanvas() {
            if (confirm('Clear entire canvas?')) {
                canvas.clear();
                emptyState.style.display = 'block';
                saveState();
            }
        }

        // --- Pan & Zoom Logic ---

        canvas.on('mouse:wheel', (opt) => {
            const delta = opt.e.deltaY;
            let zoom = canvas.getZoom();
            zoom *= 0.999 ** delta;
            if (zoom > 20) zoom = 20;
            if (zoom < 0.01) zoom = 0.01;
            canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
            opt.e.preventDefault();
            opt.e.stopPropagation();
            state.zoom = zoom;
            zoomLevelText.textContent = Math.round(zoom * 100) + '%';

            canvas.getObjects('workflow-node').forEach(node => node.syncDOM());
        });

        zoomLevelText.parentElement.onclick = () => {
            canvas.setZoom(1);
            canvas.viewportTransform[4] = 0;
            canvas.viewportTransform[5] = 0;
            canvas.requestRenderAll();
            state.zoom = 1;
            zoomLevelText.textContent = '100%';
        };

        canvas.on('mouse:down', (opt) => {
            const evt = opt.e;
            if (state.currentTool === 'hand' || evt.altKey || evt.button === 1) {
                state.isPanning = true;
                canvas.selection = false;
                state.lastPosX = evt.clientX;
                state.lastPosY = evt.clientY;
                canvas.setCursor('grabbing');
            }
        });

        canvas.on('mouse:move', (opt) => {
            const e = opt.e;

            // Sync any workflow nodes
            canvas.getObjects('workflow-node').forEach(node => node.syncDOM());

            if (state.isPanning) {
                const vpt = canvas.viewportTransform;
                vpt[4] += e.clientX - state.lastPosX;
                vpt[5] += e.clientY - state.lastPosY;
                canvas.requestRenderAll();
                state.lastPosX = e.clientX;
                state.lastPosY = e.clientY;
            } else if (state.activeArrow) {
                const pointer = canvas.getPointer(e);
                const target = canvas.findTarget(e);

                state.activeArrow.set({ x2: pointer.x, y2: pointer.y });

                if (target && target !== state.activeArrow && target !== state.activeArrow.startObj) {
                    const port = getNearestPort(target, pointer);
                    state.activeArrow.set({ x2: port.x, y2: port.y });
                }

                updateArrow(state.activeArrow);
                canvas.renderAll();
            }
        });

        canvas.on('mouse:dblclick', (opt) => {
            if (!opt.target) return;

            if (opt.target.type === 'workflow-node') {
                const input = prompt('Paste n8n Workflow JSON:');
                if (input) {
                    try {
                        const json = JSON.parse(input);
                        opt.target.workflowData = json;
                        opt.target.domElement.setAttribute('workflow', JSON.stringify(json));
                        saveState();
                    } catch (e) {
                        alert('Invalid JSON');
                    }
                }
            } else if (opt.target.type === 'markdown-block') {
                const newText = prompt('Edit Markdown:', opt.target.markdownText);
                if (newText !== null) {
                    opt.target.markdownText = newText;
                    opt.target.updateContent();
                    saveState();
                }
            }
        });

        canvas.on('mouse:up', (opt) => {
            if (state.activeArrow) {
                const pointer = canvas.getPointer(opt.e);
                const target = canvas.findTarget(opt.e);

                if (target && target !== state.activeArrow && target !== state.activeArrow.startObj) {
                    const port = getNearestPort(target, pointer);
                    state.activeArrow.set({
                        endObj: target,
                        endPort: port.id
                    });
                    updateArrow(state.activeArrow);
                }

                state.activeArrow = null;
                setTool('select');
                saveState();
            }
            state.isPanning = false;
            canvas.selection = state.currentTool === 'select';
        });

        // --- History (Undo/Redo) ---

        function saveState() {
            if (state.isHistoryAction) return;

            prepareForSave();
            // Optimization: Only serialize if there's an actual change
            const json = JSON.stringify(canvas.toDatalessJSON([
                'id', 'x1', 'y1', 'x2', 'y2',
                'startObjId', 'endObjId',
                'startPort', 'endPort',
                'markdownText', 'workflowData'
            ]));

            if (state.historyIndex === -1 || state.history[state.historyIndex] !== json) {
                state.history = state.history.slice(0, state.historyIndex + 1);
                state.history.push(json);
                state.historyIndex++;

                // Limit history size
                if (state.history.length > 50) {
                    state.history.shift();
                    state.historyIndex--;
                }

                debounceSaveToURL();
                updateUndoRedoButtons();
            }
        }

        function undo() {
            if (state.historyIndex > 0) {
                state.isHistoryAction = true;
                state.historyIndex--;
                loadStateFromJSON(state.history[state.historyIndex]);
            }
        }

        function redo() {
            if (state.historyIndex < state.history.length - 1) {
                state.isHistoryAction = true;
                state.historyIndex++;
                loadStateFromJSON(state.history[state.historyIndex]);
            }
        }

        function loadStateFromJSON(json) {
            canvas.loadFromJSON(json, () => {
                canvas.renderAll();
                state.isHistoryAction = false;
                updateUndoRedoButtons();
            });
        }

        // --- Persistence (The Magic) ---

        let saveTimeout;
        function debounceSaveToURL() {
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(saveToURL, 2000);
        }

        function prepareForSave() {
            canvas.getObjects('polyline').forEach(arrow => {
                if (arrow.startObj) arrow.startObjId = arrow.startObj.id;
                if (arrow.endObj) arrow.endObjId = arrow.endObj.id;
            });
        }

        function saveToURL() {
            try {
                prepareForSave();
                const json = JSON.stringify(canvas.toDatalessJSON([
                    'id', 'x1', 'y1', 'x2', 'y2',
                    'startObjId', 'endObjId',
                    'startPort', 'endPort',
                    'markdownText', 'workflowData'
                ]));
                const compressed = LZString.compressToEncodedURIComponent(json);
                window.history.replaceState(null, null, '#' + compressed);

                statusDot.classList.add('active');
                saveStatusText.textContent = 'Synced';
                setTimeout(() => statusDot.classList.remove('active'), 1000);
            } catch (err) {
                console.error('Save failed', err);
                saveStatusText.textContent = 'Limit reached';
            }
        }

        function loadFromURL() {
            const hash = window.location.hash.substring(1);
            if (!hash) return;
            
            try {
                document.body.classList.add('loading');
                const decompressed = LZString.decompressFromEncodedURIComponent(hash);
                if (decompressed) {
                    canvas.loadFromJSON(decompressed, () => {
                        canvas.renderAll();
                        if (canvas.getObjects().length) emptyState.style.display = 'none';
                        saveState(); // Initialize history
                        document.body.classList.remove('loading');
                    });
                } else {
                    document.body.classList.remove('loading');
                }
            } catch (err) {
                console.error('Load failed', err);
                saveStatusText.textContent = 'Load failed';
                document.body.classList.remove('loading');
            }
        }

        function exportPNG() {
            const dataURL = canvas.toDataURL({ format: 'png', multiplier: 2 });
            const link = document.createElement('a');
            link.download = 'nexus-export.png';
            link.href = dataURL;
            link.click();
        }

        function exportSVG() {
            const svg = canvas.toSVG();
            const blob = new Blob([svg], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = 'nexus-export.svg';
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
        }

        function exportJSON() {
            prepareForSave();
            const json = JSON.stringify(canvas.toDatalessJSON(), null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = 'nexus-project.json';
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
        }

        function importJSON() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = (f) => {
                    loadStateFromJSON(f.target.result);
                    saveState();
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function copyShareLink() {
            navigator.clipboard.writeText(window.location.href);
            saveStatusText.textContent = 'Link Copied!';
            statusDot.classList.add('active');
            setTimeout(() => {
                saveStatusText.textContent = 'Synced';
                statusDot.classList.remove('active');
            }, 2000);
        }

        function handleImageBtn() {
            const choice = confirm("Upload image? (Cancel for URL)");
            if (choice) {
                document.getElementById('img-input').click();
            } else {
                const url = prompt("Image URL:");
                if (url && url.trim()) {
                    fabric.Image.fromURL(url.trim(), img => {
                        if (img.width && img.height) {
                            img.scaleToWidth(Math.min(300, window.innerWidth * 0.3));
                            canvas.add(img).centerObject(img).setActiveObject(img);
                            setTool('select');
                            saveState();
                        }
                    }, { 
                        crossOrigin: 'anonymous',
                        onError: () => {
                            alert('Failed to load image. Please check the URL.');
                        }
                    });
                }
            }
        }

        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            if (!file.type.startsWith('image/')) {
                alert('Please select a valid image file.');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = f => {
                fabric.Image.fromURL(f.target.result, img => {
                    if (img.width && img.height) {
                        img.scaleToWidth(Math.min(300, window.innerWidth * 0.3));
                        canvas.add(img).centerObject(img).setActiveObject(img);
                        setTool('select');
                        saveState();
                    }
                });
            };
            reader.onerror = () => {
                alert('Failed to read the image file.');
            };
            reader.readAsDataURL(file);
        }

        // --- Fabric Events ---
        canvas.on('selection:created', () => {
            sidebar.classList.remove('hidden');
            updateSidebarFromSelection();
        });
        canvas.on('selection:updated', () => {
            sidebar.classList.remove('hidden');
            updateSidebarFromSelection();
        });
        canvas.on('selection:cleared', () => {
            if (!document.getElementById('sidebar').classList.contains('library-open')) {
                sidebar.classList.add('hidden');
            }
            document.getElementById('text-options').style.display = 'none';
        });

        function updateUndoRedoButtons() {
            document.getElementById('undo-btn').style.opacity = (state.historyIndex > 0) ? '1' : '0.3';
            document.getElementById('redo-btn').style.opacity = (state.historyIndex < state.history.length - 1) ? '1' : '0.3';
        }

        function updateSidebarFromSelection() {
            const obj = canvas.getActiveObject();
            if (!obj) return;

            if (obj.strokeWidth) strokeWidthInput.value = obj.strokeWidth;
            if (obj.opacity !== undefined) opacityInput.value = obj.opacity * 100;

            const isLocked = !!obj.lockMovementX;
            const lockBtn = document.getElementById('lock-btn');
            lockBtn.innerHTML = isLocked ? '<i data-lucide="lock"></i>' : '<i data-lucide="unlock"></i>';
            lockBtn.classList.toggle('active', isLocked);
            lucide.createIcons();

            if (obj.strokeDashArray) {
                if (obj.strokeDashArray[0] === 10) strokeDashInput.value = 'dashed';
                else if (obj.strokeDashArray[0] === 2) strokeDashInput.value = 'dotted';
                else strokeDashInput.value = 'solid';
            } else {
                strokeDashInput.value = 'solid';
            }

            if (obj.type === 'i-text' || obj.type === 'text') {
                document.getElementById('text-options').style.display = 'block';
                fontFamilyInput.value = obj.fontFamily || 'Inter';
                // For text objects, use fill color
                const textColor = obj.fill;
                if (textColor && typeof textColor === 'string') {
                    setColor(textColor);
                }
            } else {
                document.getElementById('text-options').style.display = 'none';
                // For other objects, prefer stroke color, fallback to fill
                const color = obj.stroke || obj.fill;
                if (color && typeof color === 'string') {
                    setColor(color);
                }
            }
        }

        canvas.on('mouse:down', (opt) => {
            if (state.currentTool === 'select' || state.currentTool === 'pencil' || state.currentTool === 'hand' || state.currentTool === 'eraser') return;

            const pointer = canvas.getPointer(opt.e);
            let obj;
            const strokeWidth = parseInt(strokeWidthInput.value) || 2;
            const common = {
                left: pointer.x,
                top: pointer.y,
                stroke: state.currentColor,
                strokeWidth: strokeWidth,
                fill: 'transparent',
                originX: 'center',
                originY: 'center',
                selectable: true,
                evented: true
            };

            if (state.currentTool === 'rect') {
                const fillColor = state.currentColor === 'transparent' ? 'transparent' : state.currentColor + '33';
                obj = new fabric.Rect({ 
                    ...common, 
                    width: 100, 
                    height: 100, 
                    fill: fillColor,
                    rx: 5,
                    ry: 5
                });
            } else if (state.currentTool === 'circle') {
                const fillColor = state.currentColor === 'transparent' ? 'transparent' : state.currentColor + '33';
                obj = new fabric.Circle({ 
                    ...common, 
                    radius: 50, 
                    fill: fillColor 
                });
            } else if (state.currentTool === 'text') {
                obj = new fabric.IText('Type something...', { 
                    ...common, 
                    fill: state.currentColor, 
                    fontSize: 24, 
                    fontFamily: fontFamilyInput.value || 'Inter',
                    stroke: 'transparent',
                    strokeWidth: 0,
                    objectCaching: false
                });
            } else if (state.currentTool === 'workflow') {
                obj = new fabric.WorkflowNode({ nodes: [], connections: {} }, {
                    left: pointer.x,
                    top: pointer.y
                });
            } else if (state.currentTool === 'markdown') {
                obj = new fabric.MarkdownBlock('# New Node\n- Use markdown here\n- **Bold** support\n- `Code` support', {
                    left: pointer.x,
                    top: pointer.y,
                    width: 300,
                    height: 200
                });
            } else if (state.currentTool === 'arrow') {
                const target = canvas.findTarget(opt.e);
                let startX = pointer.x, startY = pointer.y;
                let startObj = null, startPort = null;

                if (target) {
                    const port = getNearestPort(target, pointer);
                    startX = port.x;
                    startY = port.y;
                    startObj = target;
                    startPort = port.id;
                }

                const arrow = createArrow(startX, startY);
                arrow.set({ startObj, startPort });
                state.activeArrow = arrow;
                canvas.add(arrow);
                return;
            }

            if (obj) {
                setTool('select');
                canvas.add(obj);
                canvas.setActiveObject(obj);
                canvas.requestRenderAll();
                saveState();
            }
        });

        // Keyboard Shortcuts
        window.onkeydown = (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) return;

            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'z') { e.preventDefault(); undo(); }
                if (e.key === 'y') { e.preventDefault(); redo(); }
                if (e.key === 'x' && e.shiftKey) { e.preventDefault(); clearCanvas(); }
                return;
            }

            switch (e.key.toLowerCase()) {
                case 'v': setTool('select'); break;
                case 'h': setTool('hand'); break;
                case 't': setTool('text'); break;
                case 'm': setTool('markdown'); break;
                case 'w': setTool('workflow'); break;
                case 'l': document.getElementById('library-toggle').click(); break;
                case 'r': setTool('rect'); break;
                case 'o': setTool('circle'); break;
                case 'a': setTool('arrow'); break;
                case 'p': setTool('pencil'); break;
                case 'e': setTool('eraser'); break;
                case 'delete':
                case 'backspace': deleteSelected(); break;
            }
        };

        // Initialize Everything
        initUI();
        setTool('select');

        // Font loading fix
        if (document.fonts) {
            document.fonts.ready.then(() => {
                canvas.renderAll();
            });
        }
        
        // Load from URL when ready
        window.addEventListener('load', () => {
            loadFromURL();
            // Initialize first state for undo/redo
            setTimeout(() => {
                if (state.history.length === 0) {
                    saveState();
                }
            }, 100);
        });

        // Auto-save fallback with better timing
        setInterval(() => {
            if (canvas.getObjects().length > 0) {
                saveToURL();
            }
        }, 10000);

        // Canvas modification hooks with debouncing
        let modificationTimeout;
        const debouncedSaveState = () => {
            clearTimeout(modificationTimeout);
            modificationTimeout = setTimeout(saveState, 100);
        };

        canvas.on('object:moving', (e) => {
            updateConnectedArrows(e.target);
            if (e.target.type === 'workflow-node') e.target.syncDOM();
        });
        canvas.on('object:scaling', (e) => {
            updateConnectedArrows(e.target);
            if (e.target.type === 'workflow-node') e.target.syncDOM();
        });
        canvas.on('object:rotating', (e) => {
            updateConnectedArrows(e.target);
            if (e.target.type === 'workflow-node') e.target.syncDOM();
        });

        canvas.on('object:modified', debouncedSaveState);
        canvas.on('object:added', (opt) => {
            const obj = opt.target;
            if (!obj.id) obj.id = generateId();

            if (!state.isHistoryAction) {
                emptyState.style.display = 'none';
                debouncedSaveState();
            }
        });
        canvas.on('object:removed', debouncedSaveState);
        
        // Handle text editing mode
        canvas.on('text:editing:entered', (e) => {
            const textObj = e.target;
            // Ensure text color is preserved during editing
            if (textObj.fill) {
                textObj.set('stroke', 'transparent');
                textObj.set('strokeWidth', 0);
            }
        });
        
        canvas.on('text:editing:exited', (e) => {
            const textObj = e.target;
            // Ensure text properties are correct after editing
            textObj.set('stroke', 'transparent');
            textObj.set('strokeWidth', 0);
            canvas.renderAll();
            saveState();
        });
        
        // Helper to draw visual ports
        function drawPorts(obj) {
            if (!obj || obj.type === 'polyline' || obj.name === 'port-helper') return;
            ports.forEach(p => {
                const coords = getPortCoords(obj, p.id);
                const circle = new fabric.Circle({
                    left: coords.x,
                    top: coords.y,
                    radius: 4,
                    fill: '#0077FF',
                    stroke: '#FFFFFF',
                    strokeWidth: 1,
                    originX: 'center',
                    originY: 'center',
                    selectable: false,
                    evented: false,
                    name: 'port-helper'
                });
                canvas.add(circle);
            });
            canvas.renderAll();
        }

        function clearPorts() {
            const helpers = canvas.getObjects().filter(o => o.name === 'port-helper');
            canvas.remove(...helpers);
            canvas.renderAll();
        }

        canvas.on('mouse:over', (e) => {
            if (state.currentTool === 'arrow' && e.target) {
                drawPorts(e.target);
            }
        });

        canvas.on('mouse:out', (e) => {
            if (state.currentTool === 'arrow') {
                clearPorts();
            }
        });

        // Better error handling for canvas operations
        canvas.on('error', (e) => {
            console.error('Canvas error:', e);
            saveStatusText.textContent = 'Error occurred';
        });
    </script>
</body>

</html>